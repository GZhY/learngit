#《[Python教程-廖雪峰](http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)》学习笔记

## Record

1. 但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是`1.23e9`，或者`12.3e8`

2. Python还允许用`r''`表示`''`内部的字符串默认不转义

3. `/`除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数，还有一种除法是`//`，称为地板除，两个整数的除法仍然是整数

4. list如果要取最后一个元素，除了计算索引位置外，还可以用`-1`做索引，直接获取最后一个元素

5. list是一个可变的有序表，list里面的元素的数据类型也可以不同

6. 另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple

7. 因为括号`()`既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，所以，只有1个元素的tuple定义时必须加一个逗号`,`，来消除歧义

8. 要避免key不存在的错误，有两种办法，一是通过`in`判断key是否存在，如：'Thomas' in d，二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value

9. dict内部存放的顺序和key放入的顺序是没有关系的

10. 和list比较，dict有以下特点：查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多

11. dict的key必须是**不可变对象**

12. set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集&、并集|等操作

13. set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象

14. 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”

15. 数据类型检查函数：isinstance(x, (int, float))

16. 在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便

17. Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。所以，定义默认参数要牢记一点：默认参数必须指向不变对象！

18. 为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

19. 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数

20. Python允许你在list或tuple前面加一个`*`号，把list或tuple的元素变成可变参数传进去

21. `**extra`表示把`extra`这个dict的所有key-value用关键字参数传入到函数的`**kw`参数，`kw`将获得一个dict，注意`kw`获得的dict是`extra`的一份拷贝，对`kw`的改动不会影响到函数外的`extra`

22. 如果要限制关键字参数的名字，就可以用命名关键字参数，和关键字参数`**kw`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数

23. 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了

24. 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错

25. 命名关键字参数可以有缺省值，由于命名关键字参数`city`具有默认值，调用时，可不传入`city`参数，如果没有缺省值，命名关键字参数不可省略

26. 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数

27. 对于任意函数，都可以通过类似`func(*args, **kw)`的形式调用它，无论它的参数是如何定义的

28. 解决递归调用栈溢出的方法是通过**尾递归**优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的

29. 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况

30. `fact(n)`函数由于`return n * fact(n - 1)`引入了乘法表达式，所以就不是尾递归了。要改成尾递归，需要多一点代码，主要是把每一步的乘积传入到传入到递归函数中：  
   ```
   def fact(n):
       return fact_iter(n, 1)

   def fact_iter(num, product):
       if num == 1:
           return product
       return fact_iter(num - 1, num * product)
   ```

   可以看到，`return fact_iter(num - 1, num * product)`仅返回递归函数本身，`num - 1`和`num * product`在函数调用前就会被计算，不影响函数调用。

   遗憾的是，大多数编程语言（C有JAVA无）没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的`fact(n)`函数改成尾递归方式，也会导致栈溢出。

31. `L[0:3]`表示，从索引`0`开始取，直到索引`3`为止，但不包括索引`3`。即索引`0`，`1`，`2`，正好是3个元素。如果第一个索引是`0`，还可以省略`0`

32. 既然Python支持`L[-1]`取倒数第一个元素，那么它同样支持倒数切片

33. 切片例子：所有数，每5个取一个：L[::5]；前10个数，每两个取一个：L[:10:2]

34. 列表生成式例子：`[x * x for x in range(1, 11) if x % 2 == 0]` `[i.lower() if isinstance(i, str) else i for i in L1]`

35. 生成器：generator可以在循环的过程中不断推算出后续的元素，第一种方法很简单，只要把一个列表生成式的`[]`改成`()`，就创建了一个generator

36. 我们创建了一个generator后，基本上永远不会调用`next()`，而是通过`for`循环来迭代它，并且不需要关心`StopIteration`的错误

37. 定义generator的另一种方法：如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个generator

38. generator和函数的执行流程不一样。函数是顺序执行，遇到`return`语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从上次返回的`yield`语句处继续执行

39. 用`for`循环调用generator时，发现拿不到generator的`return`语句的返回值。如果想要拿到返回值，必须捕获`StopIteration`错误，返回值包含在`StopIteration`的`value`中：
   ```
   >>> g = fib(6)
   >>> while True:
   ...     try:
   ...         x = next(g)
   ...         print('g:', x)
   ...     except StopIteration as e:
   ...         print('Generator return value:', e.value)
   ...         break
   ...
   g: 1
   g: 1
   g: 2
   g: 3
   g: 5
   g: 8
   Generator return value: done
   ```

40.    可以被`next()`函数调用并不断返回下一个值的对象称为迭代器：`Iterator`，生成器都是`Iterator`对象，但`list`、`dict`、`str`虽然是`Iterable`，却不是`Iterator`，不过可以通过`iter()`函数获得一个`Iterator`对象

41.    Python的`Iterator`对象表示的是一个数据流，Iterator对象可以被`next()`函数调用并不断返回下一个数据，直到没有数据时抛出`StopIteration`错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过`next()`函数实现按需计算下一个数据，所以`Iterator`的计算是惰性的，只有在需要返回下一个数据时它才会计算

42.    `Iterator`甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的

43.    凡是可作用于`for`循环的对象都是`Iterable`类型，凡是可作用于`next()`函数的对象都是`Iterator`类型，它们表示一个惰性计算的序列

44.    结论：函数本身也可以赋值给变量，即：变量可以指向函数; 函数名其实就是指向函数的变量

45.    `map()`传入的第一个参数是`f`，即函数对象本身。由于结果`r`是一个`Iterator`，`Iterator`是惰性序列，因此通过`list()`函数让它把整个序列都计算出来并返回一个list

46.    `reduce`把一个函数作用在一个序列`[x1, x2, x3, ...]`上，这个函数必须接收两个参数，`reduce`把结果继续和序列的下一个元素做累积计算

47.    `filter()`的作用是从一个序列中筛出符合条件的元素。由于`filter()`使用了惰性计算，所以只有在取`filter()`结果的时候，才会真正筛选并每次返回下一个筛出的元素

48.    `sorted()`也是一个高阶函数。用`sorted()`排序的关键在于实现一个映射函数

49.    返回的函数在其定义内部引用了局部变量`args`，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易

50.    返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量

51.    如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变

52.    关键字`lambda`表示匿名函数，冒号前面的`x`表示函数参数；匿名函数有个限制，就是只能有一个表达式，不用写`return`，返回值就是该表达式的结果；用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突；匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数

53.    把`@log`放到`now()`函数的定义处，相当于执行了语句：`now = log(now)`；`@log('execute')`放到前面相对于：`now =  log('execute')(now)`

54.    `functools.partial`的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。注意到上面的新的`int2`函数，仅仅是把`base`参数重新设定默认值为`2`，但也可以在函数调用时传入其他值

55.    任何模块代码的第一个字符串都被视为模块的文档注释;`__author__`变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名

56.    `if __name__=='__main__': test()` 当我们在命令行运行`hello`模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该`hello`模块时，`if`判断将失败，因此，这种`if`测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试

57.    类似`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的`__author__`，`__name__`就是特殊变量，`hello`模块定义的文档注释也可以用特殊变量`__doc__`访问，我们自己的变量一般不要用这种变量名；类似`_xxx`和`__xxx`这样的函数或变量就是非公开的（private），不应该被直接引用，比如`_abc`，`__abc`等；之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。

58.    双下划线开头的变量是private变量。在Python中，变量名类似`__xxx__`的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量。一个下划线开头的实例变量名，比如`_name`，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。

59.    动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个`read()`方法，返回其内容。但是，许多对象，只要有`read()`方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了`read()`方法的对象。

60.    判断对象类型，使用`type()`函数；判断继承关系，使用isinstance()函数，并且还可以判断一个变量是否是某些类型中的一种；要获得一个对象的所有属性和方法，可以使用`dir()`函数，配合`getattr()`、`setattr()`以及`hasattr()`，我们可以直接操作一个对象的状态；通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。

61.    ​


## Reduce

## Reflect